#include<iostream>

using std::cout;
using std::cin;
using std::endl;

#pragma region 포인터 + 스마트 포인터
/*

▶ 포인터(원시 포인터)

- 값을 저장하는게 아닌 어떤 값의 주소를 저장하는 개념

- 메모리 주소를 의미하며 포인터를 통해서 데이터에 간접적으로 접근하는 것이 가능하다.
ㄴ 포인터를 활용하면 다른 영역에 있는 변수라고 할지라도 값을 변경하는 것이 가능하다.


- 포인터의 핵심

- 포인터 : 가리키는 놈 / 주소를 담는 놈

- 어떠한 값의 주소 -> 해당 값이 저장된 컴퓨터 메모리상의 주소를 의미한다.

- * : 해당 메모리에 있는 데이터 값을 가져오는 역활을 한다.

- & : 주소값을 반환하는 연산자.

- -> : 객체 멤버에 접근할 때 사용이 된다.

// 포인터는 좋은 문법인건 맞지만 메모리 상의 어떤 위치든 접근하는 것은 불가능
ㄴ 컴퓨터는 변수의 할당을 통해서 메모리의 사용 권한이 주어진 위치만 포인터를 통해서 접근하는 것을
허용한다.

▷ 포인터에 자료형이 필요한 이유

- 포인터는 단순히 메모리의 주소에 불과하다.
ㄴ 그렇기때문에 해당 정보만을 가지고는 메모리의 크기(자료형)를 정확하게 알 수가 없다.
ㄴ 포인터의 자료형을 통해서 저장 및 읽어 들일 메모리의 크기를 기본적으로 명시해야 한다.
	ㄴ 포인터와 해당 포인터에 저장 할 변수의 자료형은 반드시 일치해야 한다.


- void* : 메모리의 주소만을 보관하고 싶을때 사용한다. (특정 자료형을 명시 X)
ㄴ 해당 형태를 보이드 포인터라고 부르며 보이드 포인터는 어떠한 자료형의 메모리 주소도 보관하는 것이 가능하다.

- 또한 포인터는 메모리의 주소를 보관하는 역할을 하기 때문에 포인터의 크기는 모두 동일하다.
ㄴ 운영 체제 및 개발 환경에 따라 크기가 유동적이긴 하지만 자료형에서는 모두 동일하다,
ㄴ int* / float* / double / char * => 자료형 모두 동일


포인터 공부법 :
포인터의 핵심만 기억한 상태에서 일단 써보고 이게 왜이렇게 동작하지?로 공부법을 시작하는게 효율적이다.



- 함수의 종류

-Call By Value
ㄴ 값 전달
ㄴ EX) int AddValue(int a, int B);




-Call By Reference
ㄴ 주소 값 전달
ㄴ EX) int AddValue(int* a, int* b);

▶ 스마트 포인터




*/
#pragma endregion

void voidPointer();

// inline: 알아도 그만 몰라도 그만 / 단 깊게는 찾아보지 말것.

void linePrint()
{
	cout << "===========================================" << endl;
}




void main()
{

	cout << " 즐겁고 쉽게 재밌게 너무 최고야 -> 포인터" << endl;
	linePrint();

	/*


	- 포인터 선언 방법

	int Value = 0;			<- 메모리의 특정 영역에 4 바이트 공간 할당
	int* pnPointer = &Value;			<- Value가 할당된 메모리 공간의 첫 주소를 할당
	*/


	int ValueA = 10;

	int* pValueA = &ValueA;

	int** ppValueA = &pValueA;

	cout << *(*ppValueA) << endl; //pvalueA 참조 -> ValueA 참조 -> 10

	cout << ppValueA << endl;

	cout << ValueA << endl;

	//&ValueA
	cout << pValueA << endl;

	cout << *pValueA << endl;

	linePrint();

	/*
	- 포인터는 사용함에 있어 주의를 많이 요하는 문법

	int number;
	number = 100;

	//포인터는 사용할때 초기화를 항상 명시해야 한다.
	int* pValueA;
	pValueA = &number;

	- pValueA는 초기화를 하지 않았기 때문에 쓰레기 값을 가지고 있다.
	ㄴ 이 값은 어디에서 사용이 될 수도 있고 아닐 수도 있고... 답은 컴퓨터만 알고 있다.

	- 컴파일러 버전이 올라가면서 쓰레기 값 같은 경우 오류처리 하지 않고 넘어가 주는 경우가
	있지만 원칙적으로는 오류가 맞다.


	- 포인터가 가르키는 값을 변경할때는 꼭 확인을 하고 변경을 해줘야 한다.

	★ 이러한 패턴은 예외처리를 진행할때도 동일하게 수행된다.
	*/


	int* pValueC = NULL;

	pValueC = &ValueA;

	// 50: 50
	// 도박
	// 방어적 코딩의 필요성
	// ㄴ 널이 아닌 경우에만 변경하겠다.
	if (pValueC != nullptr)
	{
		*pValueC = 30;
	}

	cout << "포인터 배열" << endl;

	int* pAarrA[3];

	int numA = 10, numB = 20, numC = 30;
	int* pNumA = &numA;
	int* pNumB = &numB;
	int* pNumC = &numC;


	linePrint();

	cout << "문자열 포인터" << endl;

	char str1[] = "My String";
	const char* str2 = "Your String";

	/*
	Stack(정적메모리)(Stack의 최대 사이즈 : 1MB) : 
	= 라이프 사이클(메모리의 순환)의 특징을 가진다.(코드가 메모리 사용후 반환)
	heap(동적메모리) : 꽃혀있는 메모리 공간
	
	※포폴 전에는 어느정도 이해를 해야 좋다.
	변수 형태 문자열 vs 상수 형태 문자열


	- char* 같은 경우에는 메모리 공간에 문자열 "Your String"이 저장되고 문자열의 첫번째
	문자 Y의 주소값이 반환된다.

	- 두 문자열의 차이점은 아래와 같다.
	ㄴ 1. "My String" -> 10개의 길이를 지닌 str1 배열
		ㄴ str1은 그 자체로 문자열 전체를 저장하는 배열
	ㄴ 2. "Your String" -> 포인터 변수 str2에 저장된 Your String의 주소값
		ㄴ str2는 메모리상에 자동으로 저장된 Your String의 첫번째 문자를 단순히 가르키고만
		있는 포인터 변수

		-배열이름 str1은 계속해서 문자 M의 주소값이기 때문에 str1도 str2 문자열의 시작 주소값을
		담고 있다는 의미에서는 동일하다.

		-단, 배열이름 str1은 계속해서 문자 M이 저장된 위치를 가리키는 상태이여야 하지만
		포인터 변수 str2는 다른 위치를 가리킬 수 있다.
	
	
	*/

	/*
	▶ 메모리 구성 영역

	- 컴퓨터는 다양한 메모리의 구성 영역을 가지고 있다.

	1. 코드 영역(휘발성 데이터)

	- 실행할 코드가 저장되는 메모리 공간이며 CPU는 코드 영역에 저장된 명령문들을 하나씩 가져와서
	실행하는 구조를 가지고 있다.

	- 코드 영역은 운영체제에 의해서 관리되기 때문에 직접적으로 제어하는 것은 일반적으로 불가능.


	2. 데이터(휘발성 데이터)

	- 전역 변수와 static으로 선언되는 static 변수가 할당되는 공간

	- 프로그램 시작과 동시에 메모리 공간에 할당되어 프로그램 종료시까지 남아있는 특성이 있다.

	- 전역 변수, 정적 변수등 프로그램이 실행 될때 할당되고 종료될때 제거되는 영역이라고 할 수 있다.


	3. 스텍(휘발성 데이터)

	- 지역 변수와 매개변수가 할당, 선언된 함수를 빠져 나가면 소멸되는 영역

	- 시스템에 의해서 관리되는 영역


	4. 힙(휘발성 데이터)
	
	- 프로그래머에 의해서 관리되는 영역

	- 데이터 영역과 스택 영역에 할당되는 변수들은 생성과 소멸의 사이클이 정해져 있다.

	- 프로그래머가 원하는 시점에 변수를 할당(관련된 문법이 존재함)하고 소멸할 수 있는 영역이 바로 힙.
	ㄴ 프로그래머가 직접 할당하는것이므로 프로그래머가 직접 소멸해 줘야 한다.

	-만약 깜빡한다면 프로그램이 종료될 때 날라가기는 한다.


	▶ ★★동적 할당 (Dynamic Allocation)
	
	- 프로그램을 작성할 때 (컴파일 타임 or 디자인 타임) 메모리 필요량을 지정하는 정적 할당과는
	달리 실행중에 필요한만큼의 메모리를 할당하는 기법

	- 동적 할당된 메모리는 이름이 없는 변수라고 할 수 있다.

	- 정적인 메모리 영역을 차지하고 있으므로 일단 값을 기억할 수는 있지만 이름이 없으므로
	오로지 "포인터로만 접근이 허용"된다.


	★★★★★★★★★동적할당시 주의점★★★★★★★★★★★★★★★
	
	- 동적할당을 해두면 메모리에 올려진 상태로 유지가 된다.
		ㄴ 때문에 동적할당을 해놓고 사용이 끝난 시점에 반드시 해제를 해줘야 한다.


	- 동적할당을 써야만 하는 이유

	- 게임을 만들다 보면 지역 변수도 아닌 전역변수도 아닌 변수가 필요할 때가 있다.
		ㄴ EX: 함수가 매번 호출될때마다 새롭게 할당되고 또 함수를 빠져나가도 유지되는 변수

	- 지역 변수를 쓰자니 함수가 끝나면 소멸이 되고, 전역 변수를 쓰자니 이전의 값을 덮어버리기 때문에
	문제가 발생한다.

	- 만약 최대 100개의 데이터를 저장해야 할때 우리는 정적으로 100개를 할당해야 하지만
	40개의 데이터밖에 안들어오면 60개의 공간이 낭비되는 상황이 발생
		ㄴ 그렇기때문에 메모리 관리를 위해서 들어오는 족족 할당하는 기법 -> 동적 할당

	
	*/



	/*
	★★ 면접 문제 ★★
	NULL VS nullptr

	- NULL은 엄밀히 말하면 포인터가 아니다.
	ㄴ 매크로 정의된 상수 0

	ㄴ NULL의 경우는 진짜 널을 가르키는 포인터가 아니라 숫자 0을 의미한다.

	
	- nullptr
	ㄴ 널 포인터 값을 나타내는 포인터 리터럴 -> 포인터를 표현하는 값중에 NULL을 표현한 값

	ㄴ ★(핵심 라인)
	C++에서는 void*에서 다른 포인터 자료형으로 암시적 형변환이 발생하지 않기 때문에
	NULL을 포인터 초기화값으로 쓴다면 함수에 인자로 넘겨줄때 에러가 발생한다. (불편)

	ㄴ 그렇기 때문에 C++11에서 추가된 nullptr을 통해서 구현을 하는게 확장성면에서는 좋다.

		nullptr = 0 / 0에 주소 / NULL 주소

		C관련된 문법 -> NULL
		C++ 관련된 문법 -> nullptr

	*/

	

}


/*
과제 1. 수업 시간에 진행된 출력 부분 고민해보기

	int* pArrB[] = { pNumA, pNumB, pNumC };
	int** dpArr = pArrB;

	// 오늘의 과제1. 하단의 출력문에서 어떤 값이 출력될지 생각해보고(틀려도 됨), 다만 왜 이 값이 나오는 지에 대해서 논리적으로 사고해서 주석 달아보기.
	cout << pNumA << endl;

	cout << pArrB << endl;

	cout << dpArr << endl;


과제 2. 간단한 복습 과제

- 두 정수 사이의 합을 구하는 프로그램을 만들어 올 것
ㄴ 두개의 숫자를 사용자를 통해 입력 받는다.
ㄴ 입력한 두 숫자의 사이의 합을 출력하면 OK
	ㄴ 예외처리: 5번과 1번을 누른다 -> 재입력 처리 (큰 숫자가 앞에 오면 재입력)
	ㄴ 예외처리2 : 결과값이 100 미만이라면 프로그램은 계속 돌아간다.
ㄴ 또한 숫자의 합이 100이상이면 프로그램은 종료된다.
ㄴ EX) 1과 5를 입력 = 결과값: 9


- 타임 어택 과제 - (금요일 시행)
과제 3. 월남뽕

- 치트 필수

♠스페이드 / 1 ~ 13까지의 카드 
◆다이아 / 1 ~ 13까지의 카드
♥하트 / 1 ~ 13까지의 카드
♣클로버 / 1 ~13 까지의 카드

종류별 13장의 카드 => 총 52장의 카드 사용

예외처리
ㄴ A = 1
ㄴ J = 11
ㄴ Q = 12
ㄴ K = 13


- 52장의 카드를 최소 한번 랜덤으로 섞고 그후 매턴마다 3장씩 뒤집는다.


- 앞쪽에 배치된 두장의 카드를 보고 최소 배팅액 이상의 금액을 배팅
ㄴ 최소 배팅액: 1,000/ 소지금 : 10,000


- 배팅 후 세번째 카드의 수가 앞서 오픈된 카드 숫자의 사이에 있다면 배팅 금액의 10배가 되어
소지금 추가

 반대라면 소지금에서 배팅한 만큼 마이너스

※ 한 턴이 끝나고 사용된 카드는 버려져서 더 이상 사용할 수 없다.

게임 종료 조건: 소지금이 다 떨어지거나, 카드가 다 떨어지거나.

배팅 폭이 없음.




*/