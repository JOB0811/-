#pragma once
#include<iostream>

using std::cout;
using std::cin;
using std::endl;

// 13. 가상함수 + 변환 생성자/연산자

#pragma region Myregion
/*
▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되었을 경우 부모 클래스의 참조 또는 포인터를 가지고
자식 클래스의 특정 함수를 실행시키는 매커니즘을 의미한다.

- 이를 잘 활용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는 것이 가능하다.

▷ 가상 함수의 특징

- C++ 클래스의 특성중 하나인 다형성을 지우너하기 위해 "virtual" 키워드를 사용한다.

- 부모 클래스내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다.
ㄴ 이를 오버라이딩이라고 한다.

- 재정의 되지 않는다면 호출시 부모 클래스의 함수가 호출되고 재정의 되었다면 함수 호출시 자식 클래스의 함수가 호출된다.

- 다형성?

- 여러가지를 표현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는 얘기
ㄴ 클래스 캐스팅
ㄴ 자식 객체 인스턴스 -> 부모 객체 인스턴스 = 업 캐스팅
ㄴ 부모 객체 인스턴스 -> 자식 객체 인스턴스 = 다운 캐스팅

- 인스턴스

- 어느 클래스에 속하는 각 객체를 인스턴스라고 할 수 있다.

EX) 집이라는 클래스를 만들고 내 방이라는 객체를 생성 하면 그 클래스의 인스턴스가 생성된다.


▷ 함수 오버로딩(Stack에 포함)(정적 바인딩) vs 함수 오버 라이딩(heap에 포함)(정적 + 동적 바인딩)(동적 바인딩이 존재할때는 가상함수 테이블이 생성)

- 할당되는 메모리 영역의 차이가 존재

- 바인딩 차이가 존재

EX) 우리 눈에 똑같이 보이는 siege attack, marin attack, battle attack 을 어떻게 구분할 것인가 ?
-> Linker가 구분함 -> 어떻게? 네임 맹글링을 통해서 -> a1, b1, c1 등으로 네이밍을 한뒤 컴파일러에게 넘긴다.(의미를 좀 더 찾아보자.)

*/
#pragma endregion



#pragma region 객체지향
/*

▶ 객체지향 (OOP) = Object Oriented Programming

- 코드의 재사용성이 높고 코드의 관리가 용이하다.

- 이는 곧 신뢰성이 높은 프로그래밍을 가능하게 한다.
	ㄴ 어떻게든 수단과 방법을 가리지 말고 구현을 먼저 할것

▶객체지향 4대 요소 (특징)

캡슐화

- 객체의 속성을 보호하기 위해 사용한다. (캡슐화의 속성은 다양하며, 설계 단계에서 같이 들어감.)


상속

- 객체지향에서의 상속은 하위로 내려 갈수록 구체화 되는것을 의미한다.

- 잘 짜여진 상속 구조는 프로그램 구조에 대한 이해도를 상승시킨다.
	ㄴ클래스가 아무리 많다고 하더라도 최상위 클래스의 구조를 보면 하위 클래스의 동작 방식을 유추할 수 있다.

- 재사용성 향상
	ㄴ 이는 상속을 이용하여 해당 클래스에 필요한 속성 및 함수를 모두 정의하지 않고 상속을 받아서 사용할 수 있다.

- 확장성 향상
	ㄴ 일관된 형태의 객체를 추가 할 수 있으므로 간단하게 프로그램 확장이 가능하다.

- 유지보수성 향상
	ㄴ 각 객체마다 일관된 형태를 지니고 있기 때문에 유지보수에 유리하다.


다형성

- 하나의 개체가 여러 형태로 변화하는 것을 의미한다.
	ㄴ overriding


추상화 (완벽한 인터페이스)

- 공통적인 부분과 특정 특성을 분리 및 추출해 재조합 및 재구성
	ㄴ 기본적으로 추상화는 다형성 + 상속을 모두 포함할 수 있다.

- 클래스를 정의할 당시 구체화 시킬 수 없는 기능을 추상적 표현으로 정의한다.


- 객체지향 4대 특징 요약 (구현부터 챙기고 나서 이론을 챙기는 것이 중요하다)(이론을 이해하려는데 시간을 많이 투자하지 말자)

캡슐화
ㄴ 객체를 상태와 기능으로 묶는것을 의미한다.
ㄴ 객체의 내부 상태와 기능을 숨기고 허용한 상태와 기능만의 액세스 허용


상속 
ㄴ 부모 클래스의 모든 기능을 가지는 자식 클래스를 설계하는 기법


다형성 
ㄴ 부모 클래스의 함수를 자식 클래스에서 재정의하여 자식 클래스의 다른 반응을 구현하는 것에 의미가 있다.


추상화 
ㄴ 관련 특성 및 엔터티의 상호작용을 클래스로 모델링하여 시스템의 추상적 표현을 정의한다.




기술문서에 들어가야 하는 것 : 최신문법 사용성, 특징성이 포함된 코드 형식


▶ 객체지향 5대 설계 원칙 (SOLID) (4대 특징과 5대 설계 원칙은 기본으로 외우는 것이 좋다.)

1. SRP (단일 책임의 원칙)

- 결합도를 낮추고 응집도를 높여라.


※ 디자인 패턴  (유니티에는 디자인 패턴이 "무조건 들어가 있어야 한다.)

- 결합도
ㄴ 모듈간의 상호 의존 정도를 나타내는 지표
ㄴ 결합도가 높으면 코드는 답이 없어진다.. -> 롤백으로 하나하나 지우는 방법밖에 없다.
ㄴ 결합도가 낮으면 상호 의존성이 줄어서 재사용 및 유지보수에 유리하다.


- 응집도
ㄴ 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성을 의미한다.
ㄴ 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아지므로  재사용 및 유지보수에 유리하다.

※ 유효타 -> 상속 / 오버라이딩

※ 디자인 패턴


2. OCP (개방 폐쇠의 원칙) (기능의 변화에 대해서는 폐쇠적이고, 기능의 확장에 대해서는 적극적이어야 함.)

- 자신의 확장에는 열려 있고 주변의 변화에 대해서는 닫혀 있어야 한다.

- 상위 클래스 또는 인터페이스를 중간에 두어 자신의 변화에 대해서는 폐쇠하고 인터페이스는 외부 변화에 대해
확장성을 개방한다.


3. LSP (리스코프 치환의 원칙) (상위든 하위든 언제든 서로 교체할 수 있어야 함.)

- 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체할 수 있어야 한다.

EX) 상위: 자동차 / 운송수단 -> 하위 : 아반테, 그렌져

※ 설계 원칙을 만들때 들어가는 개념


4. ISP (인터페이스 분리의 원칙)

- 클라이언트는 기본적으로 자신이 사용하지 않는 함수에 의존 관계를 맺으면 안된다.

- 인터페이스로 각 기능을 분리하여 사용하는 함수에만 의존 관계를 맺는다.

- 프로젝트 요구사항과 설계에 따라서 SRP / ISP중에 1개를 선택한다.



5. DIP (의존관계 역전의 원칙)

- 자신보다 변하기 쉬운것에 의존하지 말아야 한다.

- 이는 개방폐쇄 원칙에서 살펴본 내용과 동일


- 객체지향 5대 설계 원칙 요약 (과제 or 실습을 구현하고 나서 5대 설계 요약으로 돌아와 내가 짠 코드가 하위 5개 항목이 지켜졌는지 확인해보고 수정해보기)

(S) 단일 책임 원칙
ㄴ 객체는 오직 하나의 책임을 가져야 한다.
(O) 개방 폐쇠 원칙
ㄴ 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.
(L) 리스코프 치환 원칙
ㄴ 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
(I) 인터페이스 분리 원칙
ㄴ 인터페이스는 작은 단위들로 분리시켜 구성하며 사용하지 않는 함수는 포함하지 않아야 한다.
(D) 의존성 역전 원칙
ㄴ 객체는 하위 클래스보다 상위 클래스에 의존해야 한다.

*/
#pragma endregion




#pragma region 순수 가상함수 + 추상 클래스 + 인터페이스
/*







*/
#pragma endregion





// 부모
class weapon
{
public:
	virtual void attack() { cout << "무기로 공격한다." << endl; } //부모 클래스에서는 가상화가 적용이 되어 있어야 함.
};

class gun : public weapon
{
	void attack()
	{
		cout << "총으로 공격" << endl;
	};
};

class bow : public weapon
{
public:
	void attack()
	{
		cout << "활로 공격" << endl;
	};
};




		class MainGame_05
		{
		private:
			weapon* _gun;
			weapon* _bow;
			weapon* _myWeapon;



		public:
			MainGame_05();
			~MainGame_05();
		};

