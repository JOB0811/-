#pragma once
#include<iostream>
#include<Windows.h>

using std::cout;
using std::cin;
using std::endl;

// 13. 가상함수 + 변환 생성자/연산자

#pragma region Myregion
/*
▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되었을 경우 부모 클래스의 참조 또는 포인터를 가지고
자식 클래스의 특정 함수를 실행시키는 매커니즘을 의미한다.

- 이를 잘 활용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는 것이 가능하다.

▷ 가상 함수의 특징

- C++ 클래스의 특성중 하나인 다형성을 지우너하기 위해 "virtual" 키워드를 사용한다.

- 부모 클래스내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다.
ㄴ 이를 오버라이딩이라고 한다.

- 재정의 되지 않는다면 호출시 부모 클래스의 함수가 호출되고 재정의 되었다면 함수 호출시 자식 클래스의 함수가 호출된다.

- 다형성?

- 여러가지를 표현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는 얘기
ㄴ 클래스 캐스팅
ㄴ 자식 객체 인스턴스 -> 부모 객체 인스턴스 = 업 캐스팅
ㄴ 부모 객체 인스턴스 -> 자식 객체 인스턴스 = 다운 캐스팅

- 인스턴스

- 어느 클래스에 속하는 각 객체를 인스턴스라고 할 수 있다.

EX) 집이라는 클래스를 만들고 내 방이라는 객체를 생성 하면 그 클래스의 인스턴스가 생성된다.


▷ 함수 오버로딩(Stack에 포함)(정적 바인딩) vs 함수 오버 라이딩(heap에 포함)(정적 + 동적 바인딩)(동적 바인딩이 존재할때는 가상함수 테이블이 생성)

- 할당되는 메모리 영역의 차이가 존재

- 바인딩 차이가 존재

EX) 우리 눈에 똑같이 보이는 siege attack, marin attack, battle attack 을 어떻게 구분할 것인가 ?
-> Linker가 구분함 -> 어떻게? 네임 맹글링을 통해서 -> a1, b1, c1 등으로 네이밍을 한뒤 컴파일러에게 넘긴다.(의미를 좀 더 찾아보자.)

*/
#pragma endregion



#pragma region 객체지향
/*

▶ 객체지향 (OOP) = Object Oriented Programming

- 코드의 재사용성이 높고 코드의 관리가 용이하다.

- 이는 곧 신뢰성이 높은 프로그래밍을 가능하게 한다.
	ㄴ 어떻게든 수단과 방법을 가리지 말고 구현을 먼저 할것

▶객체지향 4대 요소 (특징)

캡슐화

- 객체의 속성을 보호하기 위해 사용한다. (캡슐화의 속성은 다양하며, 설계 단계에서 같이 들어감.)


상속

- 객체지향에서의 상속은 하위로 내려 갈수록 구체화 되는것을 의미한다.

- 잘 짜여진 상속 구조는 프로그램 구조에 대한 이해도를 상승시킨다.
	ㄴ클래스가 아무리 많다고 하더라도 최상위 클래스의 구조를 보면 하위 클래스의 동작 방식을 유추할 수 있다.

- 재사용성 향상
	ㄴ 이는 상속을 이용하여 해당 클래스에 필요한 속성 및 함수를 모두 정의하지 않고 상속을 받아서 사용할 수 있다.

- 확장성 향상
	ㄴ 일관된 형태의 객체를 추가 할 수 있으므로 간단하게 프로그램 확장이 가능하다.

- 유지보수성 향상
	ㄴ 각 객체마다 일관된 형태를 지니고 있기 때문에 유지보수에 유리하다.


다형성

- 하나의 개체가 여러 형태로 변화하는 것을 의미한다.
	ㄴ overriding


추상화 (완벽한 인터페이스)

- 공통적인 부분과 특정 특성을 분리 및 추출해 재조합 및 재구성
	ㄴ 기본적으로 추상화는 다형성 + 상속을 모두 포함할 수 있다.

- 클래스를 정의할 당시 구체화 시킬 수 없는 기능을 추상적 표현으로 정의한다.


- 객체지향 4대 특징 요약 (구현부터 챙기고 나서 이론을 챙기는 것이 중요하다)(이론을 이해하려는데 시간을 많이 투자하지 말자)

캡슐화
ㄴ 객체를 상태와 기능으로 묶는것을 의미한다.
ㄴ 객체의 내부 상태와 기능을 숨기고 허용한 상태와 기능만의 액세스 허용


상속 
ㄴ 부모 클래스의 모든 기능을 가지는 자식 클래스를 설계하는 기법


다형성 
ㄴ 부모 클래스의 함수를 자식 클래스에서 재정의하여 자식 클래스의 다른 반응을 구현하는 것에 의미가 있다.


추상화 
ㄴ 관련 특성 및 엔터티의 상호작용을 클래스로 모델링하여 시스템의 추상적 표현을 정의한다.




기술문서에 들어가야 하는 것 : 최신문법 사용성, 특징성이 포함된 코드 형식


▶ 객체지향 5대 설계 원칙 (SOLID) (4대 특징과 5대 설계 원칙은 기본으로 외우는 것이 좋다.)

1. SRP (단일 책임의 원칙)

- 결합도를 낮추고 응집도를 높여라.


※ 디자인 패턴  (유니티에는 디자인 패턴이 "무조건 들어가 있어야 한다.)

- 결합도
ㄴ 모듈간의 상호 의존 정도를 나타내는 지표
ㄴ 결합도가 높으면 코드는 답이 없어진다.. -> 롤백으로 하나하나 지우는 방법밖에 없다.
ㄴ 결합도가 낮으면 상호 의존성이 줄어서 재사용 및 유지보수에 유리하다.


- 응집도
ㄴ 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성을 의미한다.
ㄴ 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아지므로  재사용 및 유지보수에 유리하다.

※ 유효타 -> 상속 / 오버라이딩

※ 디자인 패턴


2. OCP (개방 폐쇠의 원칙) (기능의 변화에 대해서는 폐쇠적이고, 기능의 확장에 대해서는 적극적이어야 함.)

- 자신의 확장에는 열려 있고 주변의 변화에 대해서는 닫혀 있어야 한다.

- 상위 클래스 또는 인터페이스를 중간에 두어 자신의 변화에 대해서는 폐쇠하고 인터페이스는 외부 변화에 대해
확장성을 개방한다.


3. LSP (리스코프 치환의 원칙) (상위든 하위든 언제든 서로 교체할 수 있어야 함.)

- 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체할 수 있어야 한다.

EX) 상위: 자동차 / 운송수단 -> 하위 : 아반테, 그렌져

※ 설계 원칙을 만들때 들어가는 개념


4. ISP (인터페이스 분리의 원칙)

- 클라이언트는 기본적으로 자신이 사용하지 않는 함수에 의존 관계를 맺으면 안된다.

- 인터페이스로 각 기능을 분리하여 사용하는 함수에만 의존 관계를 맺는다.

- 프로젝트 요구사항과 설계에 따라서 SRP / ISP중에 1개를 선택한다.



5. DIP (의존관계 역전의 원칙)

- 자신보다 변하기 쉬운것에 의존하지 말아야 한다.

- 이는 개방폐쇄 원칙에서 살펴본 내용과 동일


- 객체지향 5대 설계 원칙 요약 (과제 or 실습을 구현하고 나서 5대 설계 요약으로 돌아와 내가 짠 코드가 하위 5개 항목이 지켜졌는지 확인해보고 수정해보기)

(S) 단일 책임 원칙
ㄴ 객체는 오직 하나의 책임을 가져야 한다.
(O) 개방 폐쇠 원칙
ㄴ 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.
(L) 리스코프 치환 원칙
ㄴ 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.
(I) 인터페이스 분리 원칙
ㄴ 인터페이스는 작은 단위들로 분리시켜 구성하며 사용하지 않는 함수는 포함하지 않아야 한다.
(D) 의존성 역전 원칙
ㄴ 객체는 하위 클래스보다 상위 클래스에 의존해야 한다.

*/
#pragma endregion




#pragma region 순수 가상함수 + 추상 클래스 + 인터페이스
/*

(눈으로 예제 코드만 보고 따라치는게 특히 의미가 없는 파트임 -> 구현 능력을 올리기 위해 생각이 안나더라도 비슷한 형식을 구현하기 위해 많이 쳐봐라)
순수 가상 함수(Pure Virtual Function)
 함수에 구현부가 없고 선언부가 = 0 으로 끝나는 가상 함수를 뜻한다.

  Declare Example
  virtual void IFuntionA() - 0;
  virtual void IFuntionA() - NULL;
  virtual void IFuntionA() - PURE;
  virtual void IFuntionA() - abstract;

  ※ 특징: 부모클래스에서 순수 가상함수를 선언하면 자식클래스 에서는 반드시 재정의한 함수를 맴버로 가져와야한다.

  ★★★- 노션을 쓰는 이유 ? : 면접자(신입 예정자)에게 물어봤을때 어느정도의 성장 가능성을 보이는가?
  = 어떠한 개념의 정의를 마주했을 때 내가 어떤식으로 생각을 했다. (EX) 교수님이 우리에게 항상 시키는 한줄 정리와 같은 구도 -> 포인터? = 길잡이 느낌이구나)


▶추상 클래스 (C++ 중급 이상의 문법)

- 순수 가상 함수가 1개 이상 있는 클래스를 뜻한다.
	ㄴ 하나 이상의 순수 가상 함수를 포함하는 클래스라고 생각하면 된다.

- 클래스가 추상적인 표현을 정의하는 경우 자식에서 구체화 시켜 구현할 것을 염두하고 추상화 시킴

- 추상 클래스에서 내용을 구체화 할 수 없는 순수 가상 함수는 내용을 정의하지 않는다.

- 추상 클래스를 상속하는 자식 클래스가 순수 가상 함수를 재정의하여 구체화한 경우 사용이 가능


- 특징

1. 객체를 생성할 수 없다.

2. 단, 포인터 변수는 만들 수 있다.

3. 또한 추상 클래스로 지정한 객체는 인스턴스를 만들 수 없다.

4. 다만 추상 클래스의 자식 클래스를 통해 인스턴스를 생성할 수 있다.

5. C++ 같은 경우에는 새롭게 추가된 abstract 키워드를 통한 명시가 가능

6. 멤버 변수 또는 일반 멤버 함수가 포함된 여부와 상관없이 순수 가상함수를 1개 이상 가지고 있는 클래스는
추상 클래스라고 할 수 있다.

▶ 가상 소멸자




EX)
C++
class IWindowMessageHandler abstract
{

};


abstract class Itessellation
{

};


▶ 인터페이스

- OCP (개방 폐쇠 원칙)

- 순수 가상함수로만 이루어진 클래스를 인터페이스라고 한다.

- 인터페이스의 개념은 하위 클래스에서 반드시 정의해야 할 함수를 정해주는 클래스라고 할 수 있다.

- C++은 인터페이스라는 개념을 공식적으로 기능으로는 지원하지 않는다.

- 표기법 : 파스칼 + 헝가리안

※유니티는 포인터가 존재하지 않기 때문에 추상 클래스의 의존도가 매우 높다.

※ 인터페이스(순수 가상함수 설계) -> (상속) 추상 클래스 (기본 기능 구현) -> (상속)기본 클래스 (재정의)
↑ 인터페이스에서 추상 클래스를 생략하고 바로 기본 클래스로 가는 것이 안좋은 구조다.

- 특징

- 멤버 변수 및 함수를 포함할 수 없다. (정적 포함)

- 한정자(const, static)(속성을 바꿔주는 것) 사용 금지

- 기본 클래스를 상속받을 수 없다.

- 순수 가상 함수만 포함시켜야 한다.

- 생성 / 소멸 / 연산자 포함할 수 없다.

- public 속성을 가지고 있어야 한다.

▷ 장 / 단점

1. 상속 (다중)에서의 안정성이 증가한다.

- C++은 다중 상속을 지원하는 언어지만 설계를 고려하지 않는다면 기능이 중첩되는 중첩화 현상이 비일비재하게 발생한다.
ㄴ 이는 다이아몬드 상속 구조의 가장 큰 문제점인데 "인터페이스"는 이러한 중첩화 현상을 없애는데 탁월하다.
ㄴ 인터페이스 자체가 멤버 변수 또는 멤버 함수가 겹칠 일이 없기 때문에 다중 상속의 단점을 상쇄한다.

2. 재사용성 / 재생산성이 아주 좋다. (EX) = 적을 만들 때 첫 클래스만 잘 형성 해놓으면, 나머지는 무기만 바꾸면 생성량을 매우 끌어올릴 수 있기 때문이다.

- 기반이 되는 클래스를 1개 만들고 그 클래스에 기반하여 자식들을 정의할것이기 때문에
ㄴ 구심점이 있다는 애기

3. 추상화를 기본으로 삼아 구현되기 때문에 가독성이 떨어지고 코드 흐름을 파악하기가 어렵다.

4. C++에는 사용할 수 있는 키워드가 없으므로 프로그래머에 의한 실수가 발생할 여지가 다분하다.
	ㄴ 정확히는 강제성이 없다.


★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
(면접 질문)
▶ 가상 소멸자 (가상 소멸자 = 인터페이스를 구현하려면 세트처럼 들어온다고 생각하면 편하다.)(유니티 관련 면접 질문에서 자주 나오는 질문임)

- 인터페이스나 추상 클래스 / 혹은 가상 함수에서 동적 할당된 부모 클래스를 메모리 해제하면 자식 클래스의 소멸자를 호출해야 하는데 부모 클래스의
소멸자만 들어온다.

- 이러한 호출 순서에 의한 문제를 해결하기 위해 소멸자에도 virtual 키워드를 추가해 가상 소멸자로 만들어 줘야
자식 클래스의 소멸자를 호출할 수 있다.

※ 가상 소멸자는 상속 관계에서 잠재적인 오류에 대한 문제점을 해결할 수 있다.
ㄴ 여기에는 메모리 관리 문제도 포함이 된다. (유니티의 경우, 메모리 관리에 취약해 뭔가를 지울때마다 소멸자를 호출할텐데 소멸자를 자주 호출하게 되면 퍼포먼스 이슈가
발생하기 때문이다.)

- 가상 소멸자의 문제점
- 가상 소멸자를 호출할때마다 부모 클래스의 메모리를 해제하고, 자식 클래스의 소멸자를 호출하기 위한 과정 진행 중 성능저하 이슈가 발생할 수 있으며
가상 함수 테이블의 개념과 비슷하게 가상 소멸자 테이블을 검증하기 때문에 정적 바인딩, 동적 바인딩의 여부를 검증하는 과정에서 퍼포먼스 이슈가 발생하게 된다.

※ 고로, 성능저하 이슈가 생길 것을 고려해 "상속 관계"가 아니라면 사용을 자제해야 한다.

*/
#pragma endregion

class MainGame
{
private:

public:
	virtual void IFunctionA() = 0;
	virtual void IFunctionB() = 0;
	virtual void IFunctionC() = PURE;

	// 생 / 소 = 생략
};




__interface IGameClass // __가 붙는다는 것은 명시 키워드를 의미한다 -> 명시적 키워드(?) -> (사용한다고 명시만 해놓을 뿐, 강제성이 없다)
{
	//__int64
	virtual void idle() PURE;
	virtual void attack() PURE;

};

class CharacterChoices abstract : public IGameClass
{
private:

public:
	CharacterChoices();
	~CharacterChoices();

};


class Warrior : public CharacterChoices
{
private:

public:
	virtual void idle();
};

class Wizard : public CharacterChoices
{
private:

public:
	virtual void idle();
};





// 부모
class weapon
{
public:
	virtual void attack() { cout << "무기로 공격한다." << endl; } //부모 클래스에서는 가상화가 적용이 되어 있어야 함.
};

class gun : public weapon
{
	void attack()
	{
		cout << "총으로 공격" << endl;
	};
};

class bow : public weapon
{
public:
	void attack()
	{
		cout << "활로 공격" << endl;
	};
};




		class MainGame_05
		{
		private:
			weapon* _gun;
			weapon* _bow;
			weapon* _myWeapon;



		public:
			MainGame_05();
			~MainGame_05();
		};

