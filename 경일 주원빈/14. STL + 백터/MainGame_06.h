#include<iostream>
#include<vector>

#pragma once

using std::cout;
using std::cin;
using std::endl;


// 배열, 포인터, 클래스 다 못써도 STL 쓸줄 알면 괜찮을 정도
// STL = 자료구조 + 알고리즘에 이해도가 익숙하면 개발기간 단축 / 익숙하지 않다면 프로그램을 완성시키기 위한 직접적인 도움을 많이 받기 위한 도구 

#pragma region 알고리즘 + 자료구조
/*
▶ 알고리즘

- 문제를 해결하기 위해 정해진 진행절차나 방법을 의미한다.
ㄴ 컴퓨터에서 알고리즘은 어떠한 행동을 하기 위해서 만들어진 프로그램 명령어의 집합

- 알고리즘 조건

1. 입력
ㄴ 알고리즘은 0개 이상의 입력을 가져야 한다.


2. 출력
ㄴ 알고리즘은 최소 1개이상의 결과를 가져야 한다.


3. 명확성
ㄴ 수행 과정은 모호하지 않고 정확한 수단을 제공해야 한다.

4. 유한성
ㄴ 수행 과정은 무한하지 않고 유한한 작업 이후에 정지해야 한다.

5. 효과성
ㄴ 모든 과정은 명백하게 실행이 가능해야 한다.


- 알고리즘 성능

- 효율적인 문제해결을 위해선 알고리즘의 성능을 판단할 수 있는 기준이 필요하다.
ㄴ 이는 상황에 따라 적합한 알고리즘을 선택할 수 있도록 기준을 제시할 수 있다는것을 의미한다.

※ 평가 기준

- 컴퓨터에서 알고리즘과 자료구조의 평가는 시간과 공간, 두 자원을 얼마나 소모하는지가 효율성의 중점
	ㄴ 일반적으로 시간을 위해 공간이 희생되는 경우가 많다.
		ㄴ 공간 복잡도
		ㄴ 시간 복잡도

- Big-O 표기법

- 알고리즘의 복잡도를 나타내는 점근표기법
	ㄴ 이를 활용해 데이터 증가량에 따라 시간 증가량을 계산한다.

- 기본적으로 가장 높은 차수와 나머지 모든 항을 제거하고 표시한다.

- 알고리즘이 효율적인지 대략적인 파악을 할 수 있는 수단



▶ 자료구조

- 프로그래밍에서 데이터를 효율적인 접근 및 수정을 가능케 하는 자료의 조직 / 관리/ 저장을 의미한다.

- 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.

- 자료구조 형태

- 선형구조
ㄴ 자료간 관계가 1:1 구조
	ㄴ EX) 배열, 연결 리스트, 스텍, 큐, 덱


- 비선형구조
ㄴ 자료간 관계가 1:다 혹은 다 : 다 인 구조
	ㄴ 트리 / 그래프


*/
#pragma endregion

//알고리즘에서 안좋은 구조(퍼포먼스가 늘어나는 구조)(반복문 속에 조건문이 들어가 있는 형식)
// O(1)
int Case_1(int n)
{
	int sum = 0;
	sum = n * n;

	return sum;


}
// O(n)
int case_2(int n)
{
	int sum = 0;

	for (int i = 0; i < n; i++)
	{
		sum += n;
	}

	return sum;

}
// O(n*2)
int case_3(int n)
{
	int sum = 0;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			sum++;
		}
	}

	return sum;
}

/*
입력 값			case 1			case 2			case 3
1				  1				 1				  1
10				  1				 10				 100
100				  1				 100			10,000
1000			  1				 1000			10,000,000
n				  O(1)			 O(n)			 O(n*2)
Big-O			 최선			 평균			  최악

알고리즘 방향성은 거의 case2를 추구하는 것이 좋다.
최악의 알고리즘 복잡도를 피하는 방법 -> (조건문,반복문,Boolean)구조 줄이기
*/



int FindIndex(int array[], int start, int end, int value)
{
	for (int i = start; i <= end; i++)
	{
		if (array[i] == value)
		{
			return i;
		}
	}
	return -1;
}





#pragma region STL 벡터 + 이터레이터
/*

▶ 벡터란?

- STL에 속해 있는 컬렉션 클래스 중 하나로서 배열처럼 동작하는 컬렉션 클래스를 의미한다.

- 일반적인 배열에 비해 데이터를 추가하기 위한 갯수가 제한되어 있지 않기 때문에 컴퓨터가 허락하는 한 많은 양의
데이터를 추가하는 것이 가능하다.

- STL 벡터는 시퀀스 기반이다.
ㄴ 별다른 규칙이나 제약이 존재하지 않는 일반적인 컨테이너

- 시퀀스 컨테이너는 데이터를 선형으로 저장하며 시퀀스 컨테이너는 삽입 된 요소의 순서가 그대로 유지된다는 특징이 있다.

- 시퀀스 컨테이너

- 기본적인 컨테이너의 몇가지 규칙을 만족한다면 시퀀스 컨테이너가 된다.
	ㄴ 대표적으로 vector, list, deque 등이 있다. (C#에서는 list가 vector의 역할을 할 수있다 -> list를 array list로 사용하면 vector의 역할을 대체한다.)

1. 모든 요소는 직선 순서대로 배치되어야 한다.
ㄴ. 이 얘기는 첫번째 요소와 마지막 요소를 제외한 나머지 요소들은 반드시 앞뒤로 인접한 요소를 하나씩 가지고 있어야 한다.

2. 최소한 순방향 반복자를 가지고 있어야 한다. (forward)
ㄴ 이는 최소한 반복자가 이동할때마다 요소들의 순서가 변하지 않음을 보장해주는 것.

3. 시퀀스 컨테이너의 요소들은 명확한 순서를 가진다.
ㄴ 그러므로 특정 위치를 참조하는 연산이 가능해야 한다.

▷ 벡터의 특징 
★(포트폴리오를 작성할 때 벡터의 특징중 "메모리 소모량이 크다"라는 것에서 발목이 잡히면 안된다. 중요한 것은 내가 STL(Vector)를 사용할줄 안다는 것을 보여주는 것이지
포트폴리오를 작성할때는 Vector를 사용할줄 안다는 것에 초점을 두자.)
★★★★★★ 면접 질문 -> 백터와 리스트는 어떠한 차이점을 가지고 있나? ★★★★★★
point! -> 1줄짜리 데이터 구조를 그려놓고, 백터의 데이터 처리 방식 <-> 리스트 처리 방식을 비교해서 말할 수 있으면 best!
(벡터는 빈공간을 매꾸기 위한 특성을 가지고 있고, 백터는 삽입/삭제 구조에 용이한 형식이 아니지만 리스트는 이러한 백터의 단점을 극복한 구조이다.)
(Vector는 

- 시퀀스 기반

- 배열 기반 컨테이너

- C++에서 활용 빈도가 높고 사용하기가 쉽다.
	ㄴ 이는 C#의 List + foreach 콤보로 이어진다.

- 검색 속도가 빠르다.
ㄴ 읽기 능력이 탁월하다.

- 대신 입출력은 느리다.(데이터의 삽입/삭제가 발생할 때 입출력이 지속적으로 느려질 것이다. -> 

- 대표적 특징으로는 새로운 메모리를 할당해 새로 추가한 원소와 함께 복사한다.

- 메모리 소모량이 크다.


▶ 이터레이터란?
- 이터레이터가 반복이 가능한 이유는 "스마트 포인터"에 의해서 가능하다.
스마트포인터 ? = 할당은 사용자가 하되, 해제는 자동으로 되는 것을 의미한다.

- 스마트 포인터로 구현되어 있는 대표적인 컬렉션 클래스

- 컬렉션 클래스에 보관되어 있는 각 데이터에 접근하기 위한 포인터 객체로서 STL에 포함되어 있는 모든 컬렉션 클래스는
데이터 시작과 끝을 나타내는 Begin()과 end() 함수를 지니고 있기 때문에 이터레이터를 사용할 수 있다.

- 따라서 begin()부터 시작해서 end()까지 루프를 반복하게 되면 컬렉션에 포함되어 있는 모든 데이터에 접근하는 것이 가능하다.

// 이터레이터 요약
- 자료구조에 저장되어 있는 요소들을 반복하고 개별 요소에 대해 접근을 제공하는 객체라고 생각하면 편하다.
ㄴ C++의 모든 자료구조는 반복자를 제공하고 있다.

- 또한, C++의 알고리즘은 반복자를 통해 구현하기 때문에 자료구조 종류와 무관하게 동작이 가능하다.


순차 리스트 (선형)
ㄴ 인덱스를 하나씩 증가시키며 반복


연결 리스트 (비선형)
ㄴ 다음 노드를 이동하며 반복
*/
#pragma endregion


#pragma region 순차 리스트
/*






*/
#pragma endregion


struct  STData
{
	int m_nValue;
	std::string m_oString;
};


class MainGame_06
{
private:
	//vector<MainGame_06*> _mg; -> mg를 cpp파일에 선언해서 뭘할 수 있을지를 생각해보자.
	//정수형 벡터 선언
	std::vector<int> _vNumber;
	// 정수형 벡터 반복자 선언
	std::vector<int>::iterator _viNumber;
	std::vector<int>::reverse_iterator _vriNumber;


public:
	void printVector();
	inline void LinePrint() { cout << "============================" << endl; }

	// 2.
	void sampleVector(std::vector<int> ValueList);
	void sampleSTVector(std::vector<STData> ValueList);
	void practiceVector(void);


	MainGame_06();
	~MainGame_06();
};


/*
과제 1. 함수와 벡터의 만남

- 수업 시간에 작성된 샘플 함수를 효율성 있고 재생산성 있게 구현해 오도록

- 함수 원형은 건들지 않는다.


*/

/*
과제2. 턴제 대전 게임 만들기 (포트폴리오에 쓸 도트를 미리 찍어서 캐릭터로 사용하는 것이 좋을것임.)

- 클래스는 6개 이상

- 클래스를 사용해서 구현할 것(객체지향)

- 스타트씬과 게임 씬으로 구성

- 도트와 색상 + HP바 필수
ㄴ 도트는 본인의 포트폴리오 도트를 사용해도 무방

- 자동 전투가 아닌 한턴씩 치고받게 구현해 올것
ㄴ 플레이어 : 스킬 2개 / 적: 스킬 2개 만들기


- 게임 오버 조건 만들어 올것

- 기본 베이스는 좌우 대칭으로 구성한다.


*/
